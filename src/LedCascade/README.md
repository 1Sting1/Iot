# Управление пятью светодиодами с разными периодами мигания с использованием таймера и прерываний

## 1. Цель

Целью данной работы является создание программы для микроконтроллера AVR (на примере ATmega328P), которая управляет пятью светодиодами, подключенными к одному порту. Каждый светодиод должен мигать с индивидуальной, независимой частотой. Решение должно быть реализовано без использования блокирующих функций (`delay()`) и стандартных функций Arduino (`pinMode()`, `digitalWrite()`), вместо этого применяя прямое управление регистрами и обработку прерываний от аппаратного таймера.

## 2. Принцип работы и ключевые концепции

Основная идея решения заключается в использовании аппаратного таймера микроконтроллера для создания точных временных интервалов. Вместо того чтобы останавливать выполнение всей программы, таймер работает в фоновом режиме и по истечении заданного интервала генерирует прерывание. Специальная функция — обработчик прерывания (ISR) — выполняется автоматически, не затрагивая основной цикл программы `loop()`. Внутри этой функции и реализована вся логика управления состоянием светодиодов.

### 2.1. Использование таймера в режиме CTC (Clear Timer on Compare Match)

Для задачи был выбран 16-битный `Timer1`, поскольку он обеспечивает большую точность и более широкий диапазон временных интервалов по сравнению с 8-битными таймерами.

Таймер настроен на работу в режиме **CTC (Сброс по совпадению)**. В этом режиме счетчик таймера (`TCNT1`) постоянно увеличивается. Когда его значение достигает величины, записанной в регистр сравнения (`OCR1A`), происходят два события:

1.  Генерируется прерывание `TIMER1_COMPA_vect`.
2.  Счетчик `TCNT1` автоматически сбрасывается в ноль и начинает считать заново.

Такой подход позволяет создавать периодические прерывания с очень высокой точностью.

### 2.2. Расчет временных интервалов

Точность работы системы зависит от правильной настройки предделителя таймера и значения в регистре сравнения `OCR1A`.

*   **Тактовая частота микроконтроллера:** 16 МГц.
*   **Выбранный предделитель:** 64. Это означает, что счетчик таймера будет инкрементироваться не на каждой тактовой частоте, а в 64 раза медленнее.
*   **Частота работы таймера:** 16 000 000 Гц / 64 = 250 000 Гц (или 250 кГц).
*   **Период одного тика таймера:** 1 / 250 000 с.

Чтобы создать базовый временной интервал, на основе которого будут работать все светодиоды (например, 10 мс или 100 Гц), необходимо рассчитать значение для `OCR1A`:

```
Значение OCR1A = (Частота таймера / Желаемая частота прерываний) - 1
Значение OCR1A = (250 000 / 100) - 1 = 2500 - 1 = 2499
```

Таким образом, при записи `2499` в `OCR1A`, прерывание будет генерироваться ровно 100 раз в секунду, то есть каждые 10 миллисекунд. Этот интервал является минимальной единицей времени ("тиком") для нашей программы.

### 2.3. Логика в обработчике прерываний

Вся логика переключения светодиодов находится внутри функции `ISR(TIMER1_COMPA_vect)`. Эта функция вызывается автоматически каждые 10 мс.

*   **Массив периодов (`led_periods`)**: Этот массив хранит, через сколько "тиков" (10-миллисекундных интервалов) должен переключаться каждый светодиод. Например, значение `3` для третьего светодиода означает, что он будет менять свое состояние каждые `3 * 10 = 30 мс`.
*   **Массив счетчиков (`led_counters`)**: Для каждого светодиода заведен отдельный счетчик. Этот счетчик инкрементируется при каждом вызове прерывания.
*   **Логика сравнения**: Внутри ISR для каждого светодиода проверяется условие: `if (led_counters[i] >= led_periods[i])`.
*   **Переключение состояния**: Если условие истинно, значит, настало время переключить светодиод. Для этого используется побитовая операция **XOR (`^`)** с регистром `PORTB`. Выражение `PORTB = PORTB ^ (1 << i);` инвертирует i-й бит порта B, не затрагивая остальные. Если бит был 1, он станет 0, и наоборот. Это эффективный способ переключения состояния пина.
*   **Сброс счетчика**: После переключения состояния светодиода его персональный счетчик (`led_counters[i]`) сбрасывается в 0, и цикл отсчета для него начинается заново.

## 3. Аппаратная конфигурация

*   Светодиоды подключены к пинам порта B: `PB0`, `PB1`, `PB2`, `PB3`, `PB4` (на плате Arduino Uno это цифровые пины 8, 9, 10, 11, 12).
*   Настройка пинов на выход осуществляется через регистр направления данных `DDRB` путем установки соответствующих битов в 1.
    ```c
    DDRB = DDRB | ((1 << DDB0) | ... | (1 << DDB4));
    ```
*   Начальное состояние светодиодов (включены) задается записью в регистр данных `PORTB`.
    ```c
    PORTB = PORTB | ((1 << PORTB0) | ... | (1 << PORTB4));
    ```