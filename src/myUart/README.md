# Программная реализация UART на AVR: Подробное описание

Этот документ описывает программную реализацию асинхронного последовательного приемопередатчика (UART) для микроконтроллеров AVR. Решение не использует аппаратный модуль USART, а полностью эмулирует его функциональность с помощью стандартных портов ввода-вывода (GPIO), одного 16-битного аппаратного таймера (Timer1) и системы прерываний.

Такой подход, известный как "bit-banging", обеспечивает гибкость в выборе выводов микроконтроллера для связи и позволяет реализовать UART-интерфейс, даже если все аппаратные модули уже заняты.

**Ключевые особенности решения:**

*   **Полностью асинхронная работа:** Процессы приема (RX) и передачи (TX) выполняются в фоновом режиме с помощью прерываний, не блокируя основной цикл программы (`loop`).
*   **Полнодуплексный режим:** Прием и передача данных могут происходить одновременно и независимо друг от друга благодаря использованию двух каналов сравнения одного и того же таймера.
*   **Точное управление временем:** Аппаратный таймер используется для генерации точных временных интервалов, определяющих скорость передачи данных (baud rate).
*   **Буферизация:** Используются кольцевые (циклические) буферы для временного хранения отправляемых и принимаемых данных, что предотвращает их потерю.
*   **Низкоуровневая реализация:** Управление периферией осуществляется напрямую через регистры (DDRx, PORTx, PINx, TCCRx, и т.д.), что обеспечивает максимальную производительность и контроль.

## 2. Логика работы

### 2.1. Основа: Таймер и прерывания

Сердцем всей системы является **Timer1**. Он настраивается на работу с предделителем и непрерывно считает такты системного генератора. Скорость передачи данных (бодрейт) определяет длительность одного бита. Эта длительность пересчитывается в количество "тиков" таймера.

*   **Длительность бита (T_bit):** `1 / baud_rate` (в секундах)
*   **Тиков на бит (timer_ticks_per_bit):** `(F_CPU / prescaler) / baud_rate`

Именно это значение (`timer_ticks_per_bit`) используется для точного отсчета времени между битами. Вместо циклов ожидания (`delay()`) используются прерывания по совпадению. Мы задаем таймеру значение, при достижении которого он генерирует прерывание. Внутри обработчика прерывания мы выполняем короткое действие (например, меняем состояние вывода) и сразу же планируем следующее прерывание, добавляя `timer_ticks_per_bit` к регистру сравнения.

### 2.2. Процесс передачи (TX)

1.  **Буферизация:** Когда пользователь вызывает `uart_send()` или `uart_send_string()`, данные не отправляются немедленно. Они помещаются в кольцевой буфер `tx_buffer`. Это позволяет основному коду быстро "сбросить" данные для отправки и продолжить свою работу.

2.  **Инициация передачи:** Функция `uart_send()` проверяет, активен ли уже процесс передачи. Если передатчик находится в режиме ожидания (прерывание `TIMER1_COMPA_vect` выключено), она запускает процесс:
    *   Активирует прерывание по совпадению для канала A (`TIMSK1 |= (1 << OCIE1A)`).
    *   Планирует первое прерывание, которое и начнет передачу первого байта из буфера.

3.  **Побитовая отправка в `ISR(TIMER1_COMPA_vect)`:**
    *   **Загрузка байта:** Если начинается передача нового байта, он извлекается из `tx_buffer`. На его основе формируется 10-битный пакет в переменной `tx_shift_register`: `[Стоп-бит (1)] [8 бит данных] [Старт-бит (0)]`.
    *   **Передача бита:** При каждом срабатывании прерывания:
        1.  Текущее состояние вывода `TX_PIN` устанавливается в соответствии с младшим битом `tx_shift_register`.
        2.  `tx_shift_register` сдвигается на один бит вправо, подготавливая следующий бит к отправке.
        3.  Планируется следующее прерывание путем добавления `timer_ticks_per_bit` к регистру `OCR1A`.
    *   **Завершение передачи:** После отправки всех 10 бит ISR проверяет, есть ли еще данные в `tx_buffer`.
        *   Если **да**, загружается следующий байт, и процесс повторяется.
        *   Если **нет**, прерывание `TIMER1_COMPA_vect` отключается, а линия TX переводится в состояние ожидания (логическая '1').

### 2.3. Процесс приёма (RX)

Прием данных более чувствителен ко времени, так как мы должны "слушать" линию в правильные моменты, чтобы корректно прочитать биты.

1.  **Обнаружение старта (`ISR(INT0_vect)`):**
    *   Для обнаружения начала передачи используется внешнее прерывание `INT0`, настроенное на спадающий фронт (переход из '1' в '0'). Это соответствует стартовому биту.
    *   Как только прерывание срабатывает:
        1.  Оно немедленно отключается (`EIMSK &= ~(1 << INT0)`), чтобы избежать ложных срабатываний от последующих битов данных.
        2.  **Планируется первая выборка:** Самый важный шаг. Чтобы прочитать бит в его середине (где сигнал наиболее стабилен), первое прерывание таймера для чтения планируется через **1.5** битового интервала от момента обнаружения спадающего фронта. `OCR1B = TCNT1 + timer_ticks_per_bit + (timer_ticks_per_bit / 2);`
        3.  Активируется прерывание по совпадению для канала B (`TIMSK1 |= (1 << OCIE1B)`).

2.  **Сэмплирование битов в `ISR(TIMER1_COMPB_vect)`:**
    *   При каждом срабатывании этого прерывания (которое будет происходить ровно через каждый `timer_ticks_per_bit` после первого):
        1.  Считывается логический уровень на выводе `RX_PIN`.
        2.  Считанный бит сдвигается в переменную `rx_byte`.
    *   Процесс повторяется 8 раз для сбора всех битов данных.

3.  **Завершение приёма:**
    *   После считывания 8-го бита:
        1.  Прерывание `TIMER1_COMPB_vect` отключается.
        2.  Полностью собранный байт помещается в кольцевой буфер `rx_buffer`.
        3.  Внешнее прерывание `INT0` снова включается, чтобы система была готова к приему следующего байта.

### 2.4. Обеспечение полнодуплексного режима

Ключевым моментом для одновременной работы TX и RX является использование **двух независимых каналов сравнения** (Compare Channels) таймера Timer1:
*   **Канал A (`OCR1A` и `TIMER1_COMPA_vect`)** полностью выделен для передатчика.
*   **Канал B (`OCR1B` и `TIMER1_COMPB_vect`)** полностью выделен для приёмника.

Поскольку оба канала работают с одним и тем же счетчиком `TCNT1`, но имеют независимые регистры сравнения (`OCR1A`, `OCR1B`) и векторы прерываний, их работа не конфликтует. Передатчик может планировать свои прерывания, а приёмник — свои, и они будут выполняться по мере наступления соответствующих событий сравнения.

## 3. Безопасность данных и работа с прерываниями

*   **`volatile`:** Все переменные, которые используются как в основном коде, так и в обработчиках прерываний (например, `tx_buffer`, `rx_buffer`, их указатели `head`/`tail`), объявлены с ключевым словом `volatile`. Это запрещает компилятору применять оптимизации, которые могли бы привести к использованию устаревших значений переменных, кешированных в регистрах процессора.
*   **`ATOMIC_BLOCK`:** Доступ к разделяемым данным (в основном, к указателям буферов `head` и `tail`) обернут в атомарные блоки. Это гарантирует, что операция чтения или изменения многобайтовой переменной (например, `head` и `tail`) не будет прервана другим прерыванием, что могло бы привести к состоянию гонки и повреждению структуры данных буфера.

## 4. Описание API

*   `void uart_set_baudrate(long rate)`
    *   Инициализирует GPIO, настраивает Timer1 и прерывания в соответствии с заданной скоростью `rate`. Должна быть вызвана один раз в `setup()`.
*   `void uart_send(char b)`
    *   Помещает один байт `b` в буфер для последующей отправки. Если буфер полон, функция ожидает освобождения места (блокирующая операция).
*   `void uart_send_string(const char *msg)`
    *   Последовательно отправляет все символы строки `msg` с помощью `uart_send()`.
*   `uint8_t uart_available()`
    *   Возвращает количество байт в приёмном буфере `rx_buffer`, доступных для чтения.
*   `char uart_read()`
    *   Извлекает и возвращает старейший байт из `rx_buffer`. Если буфер пуст, поведение не определено (в данной реализации возвращает -1).
*   `bool uart_read_string(char *rx_data)`
    *   Считывает все доступные байты из `rx_buffer` в предоставленный массив `rx_data` и добавляет нулевой терминатор. Возвращает `true`, если были считаны какие-либо данные.
